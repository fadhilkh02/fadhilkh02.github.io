<!DOCTYPE html>
<html lang="">

<head>
    <title>Tugas Pertemuan 4 Jaringan Komputer Kelas B 2019</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="" />
    <script>
        addEventListener("load", function() {
            setTimeout(hideURLbar, 0);
        }, false);

        function hideURLbar() {
            window.scrollTo(0, 1);
        }
    </script>
    <!-- Custom Theme files -->

    <link rel="icon" href="../../images/icon.png" type="image/x-icon">
    <link href="../../css/bootstrap.css" type="text/css" rel="stylesheet" media="all">
    <link href="../../css/style.css" type="text/css" rel="stylesheet" media="all">
    <!-- nav -->
    <link href="../../css/menufullpage.css" rel="stylesheet">
    <!-- gallery css -->
    <link href="../../css/prettyPhoto.css" rel="stylesheet" type="text/css" />
    <!-- font-awesome icons -->
    <link href="../../css/fontawesome-all.min.css" rel="stylesheet">
    <!-- //Custom Theme files -->
    <!-- online-fonts -->
    <link href="//fonts.googleapis.com/css?family=Fira+Sans+Condensed:100,100i,200,200i,300,300i,400,400i,500,500i,600,600i,700,700i,800,800i,900,900i" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Changa:wght@500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Changa:wght@500&family=Merienda:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Amatic+SC:wght@700&family=Architects+Daughter&family=Electrolize&family=Staatliches&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Cutive+Mono&family=Merienda+One&family=Michroma&display=swap" rel="stylesheet">

    <link href="https://fonts.googleapis.com/css2?family=Cutive+Mono&family=Merienda+One&family=Michroma&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>

    <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Concert+One&display=swap" rel="stylesheet">



    <!-- //online-fonts -->
</head>

<body>
    <!-- inner banner -->
    <div class="inner-banner-agile banner-port1">
        <!-- header -->
        <header>
            <!--nav -->

            <a href="#menu" class="menu-link">
                <span>toggle menu</span>
            </a>
            <nav id="menu" class="panel">
                <ul>
                    <li>
                        <a href="../../index.html">Home</a>
                    </li>
                    <li>
                        <a href="../../about.html">About</a>
                    </li>
                    <li>
                        <a href="../../matkul.html" class="active">Mata Kuliah</a>
                    </li>
                </ul>
            </nav>
            <!-- //nav -->
            <!-- logo -->
        </header>
        <!-- //header -->
        <div id="text" class="banner_text_w3ls2" style="text-align:center;font-family: 'Changa', sans-serif; font-size: 5vmax;"></div>
    </div>

    <section class="experience" id="experience">
        <div class="container py-4">
            <h3 class="judul"> Tugas Jaringan Komputer Pertemuan 5 Kelas B</h3>
            <div class="middile-inner-con">
                <div class="tab-main mx-0">

                    <input id="tab1" type="radio" name="tabs" checked>
                    <label for="tab1"><img src="images/s1.png" alt=""  />&emsp; 1. Introduction Reliable Data Transfer (rdt) using a Finite State Machine (FSM)</label>

                    <input id="tab2" type="radio" name="tabs" checked>
                    <label for="tab2"><img src="images/s2.png" alt="" />&emsp; 2. Sender sides of rdt 3.0 use FSM</label>

                    <input id="tab3" type="radio" name="tabs" checked>
                    <label for="tab3"><img src="images/s4.png" alt="" />&emsp; 3. Receiver sides of rdt 3.0 use FSM</label>





                    <section id="content1">
                        <div class="menu-grids">
                            <div class="t-in">
                                <div class="text-info-sec">
                                    <div class="service-in text-left">
                                        <div class="cover">
                                            <div class="isian p-0 ">
                                                <h1 style="padding-left: 100px; padding-right: 50px; text-align: center;"> Introduction Reliable Data Transfer (rdt) using a Finite State Machine (FSM)</h1>
                                                <img src="../../images/15.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">


                                                <p>&emsp; &emsp;FSM menggunakan dua komponen pada diagramnya yaitu :
                                                    <li>Lingkaran, Sebagai label sesuai dengan nama state tersebut.</li>
                                                    <li>Anak Panah, Sebagai transisi yang terjadi. Label di anak panah menyatakan simbol yang membuat transisi dari 1 state ke state lain .1 anak yang putus-putus panah diberi label start/inputan untuk menyatakan
                                                        awal mula transisi dilakukan.</li>

                                                </p>

                                                <p>&emsp; &emsp;Dan Reliable Data Transfer (rdt) yang tujuannya pada layer jaringan internet adalah menyediakan layanan dan upaya terbaik dalam hal jaminan pengiriman paket hingga tiba di tujuan. Permasalahan
                                                    yang mendasari adanya lapisan jaringan internet adalah karena setiap paket yang diarahkan secara individu memungkinkan adanya kerusakan. Untuk layanan yang berbasis Connection Oriented yang disediakan
                                                    TCP, perlu memiliki protokol yang disebut Reliable Data Transfer (RDT) yang memastikan bahwa semua paket yang dikirim bisa sampai pada tujuan hingga ke lapisan teratas (Application Layer). Secara dasar,
                                                    RDT menggunakan protokol Stop-and-Wait. Cara kerjanya adalah setelah mengirim setiap paket, sender akan berhenti mengirim dan menunggu feedback dari penerima yang menandakan bahwa paket telah sampai
                                                    tujuan. Namun, karena alasan jarak yang jauh, muncul berbagai versi update yang ada di RDT Ada beberapa versi dari RDT diantaranya :

                                                    <h2>1. rdt:1.0</h2>
                                                    <p>&emsp; &emsp;Untuk Versi ini merupakan versi dasar dari rdt, dimana ketika Sender mengirim sebuah paket data, maka paket data selanjutnya akan dikirim jika Receiver telah menerima paket bahwa paket data
                                                        yang telah dirikirim sudah diterima. Kelemahan rdt 1.0 yaitu Tidak ada pengecekan bit eror pada setiap paket. </p>

                                                    <p>&emsp;&emsp;&emsp;Sender:
                                                        <img src="../../images/16.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">

                                                        <li>Menunggu panggilan dari layer diatasnya (layer aplikasi), </li>
                                                        <li>Ketika ada perintah maka jalankan fungsi packet=make_pkt</li>
                                                        <li>Paket dikirimkan dengan memakai fungsi udt_send(packet)</li>
                                                    </p>

                                                    <p>&emsp; &emsp;&emsp;Receiver:
                                                        <img src="../../images/16a.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">
                                                        <li>Fungsi rdt_rcv yaitu menunggu panggilan dari bawah(layer data link)</li>
                                                        <li>Ketika ada sinyal maka dia menerima paket </li>
                                                        <li>Dan akan dijalankan fungsi extract yaitu mengekstrak paket data </li>
                                                        <li>Selanjutnya dikirim ke layer aplikasi(di sisi penerima).</li>
                                                    </p>

                                                    <h2>2. rdt2.0 </h2>
                                                    <p>&emsp; &emsp; Pada versi ini, disisi Sender ada 2 macam state. Pertama adalah state yang menunggu data untuk dikirimkan. Kedua adalah state yang menunggu adanya ACK atau NAK yang dikirim dari Receiver.
                                                        Disisi Reciever, masih menggunakan 1 state saja yaitu hanya mengirimkan ACK atau NAK tergantung pada paket yang diterima, apakah corrupt atau tidak. rdt2.0 hadir karena Memperbaiki kelemahan dari
                                                        rdt 1.0 yaitu dengan adanya checksum untuk mendeteksi bitnya eror atau tidak. rdt2.0 mencoba meniru bagaimana cara manusia berdialog, yaitu ketika 2 orang sedang berbicara jika yang satunya kurang
                                                        mengerti akan bertanya ‘maaf kamu tadi bilang apa? ‘ yang menandakan bahwa dia tidak menangkap pembicaraan. </p>

                                                    <p>&emsp;&emsp;&emsp;Sender:
                                                        <img src="../../images/17.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">

                                                        <li>Menunggu panggilan dari atas (layer aplikasi) </li>
                                                        <li>Ketika ada perintah maka jalankan fungsi packet=make_pkt(data,checksum) yaitu membuat paket dan menyertakan checksum. </li>
                                                        <li>Packet data dikirimkan lewat udt_send. </li>
                                                        <li>Jika mendapat ACK, berarti packet telah sampai dan tidak corrupt. </li>
                                                        <li>Jika mendapat NAK maka udt_send mentransmisikan ulang yaitu pada fungsi rdt_rcv(rcvpkt)&&is NAK(rcv_pkt) dan udt_send yang mengirimkan file itu lagi. </li>
                                                        <li>Jika mendapat ACK, berarti packet telah sampai dan tidak corrupt. </li>
                                                    </p>

                                                    <p>&emsp; &emsp;&emsp;Receiver:
                                                        <img src="../../images/18.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">
                                                        <li>Fungsi rdt_rcv menunggu panggilan dari bawah(layer data link) </li>
                                                        <li>Ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak </li>
                                                        <li>Jika tidak maka selanjutnya akan dijalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya dikirim ke layer aplikasi(di sisi penerima) dan ia juga mengirim ACK melalui udt_send. </li>
                                                        <li>Jika rusak maka selanjutnya akan dijalankan fungsi rdt_rcv(rcv_pkt)&& corrupt(rcvpkt) maka udt_send mengirim NAK. </li>

                                                        <li>Lalu rdt_rcv menunggu panggilan dari bawah(layer data link), ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak, jika tidak maka selanjutnya akan dijalankan fungsi extract
                                                            yaitu mengekstrak paket data untuk selanjutnya dikirim ke layer aplikasi(di sisi penerima) dan ia juga mengirim ACK melalui udt_send. </li>
                                                    </p>

                                                    <h2>3. rdt2.1 </h2>
                                                    <p>&emsp; &emsp; Pada versi ini, paket data ditambahkan field yang berisi Sequence Number. Dengan demikian, Reciever hanya perlu memeriksa isi field tersebut untuk mendefinisikan apakah paket perlu di kirim
                                                        ulang atau tidak. rdt2.1 Memperbaiki kelemahan rdt 2.0 yaitu dengan menambahkan sequence number pada setiap paket. Carakerjanya samadengan rdt2.0 hanya saja ada 2 paket dan diberikan sequence number
                                                        yaitu ‘0’ dan ‘1’.</p>

                                                    <p>&emsp;&emsp;&emsp;Sender:
                                                        <img src="../../images/19.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">

                                                        <li>Pada state 1 disisi sender menunggu panggilan dari atas (layer aplikasi), ketika ada perintah maka jalankan fungsi packet=make_pkt(0,data,checksum) yaitu membuat paket dan memberi sequence number
                                                            0 dan menyertakan checksum yang akan dikirimkan lewat udt_send. </li>
                                                        <li>Lalu berada pada state ke 2 yaitu menunggu untuk ACK atau NAK dimana ada 2 kemungkinan yaitu jika NAK maka data rusak dan segera kembali mentransmisikan paket 0 melalui udt_send lagi. </li>
                                                        <li>Lalu berada pada state ke 3 yaitu menunggu panggilan dari atas (layer aplikasi) lagi, ketika ada perintah maka jalankan fungsi packet=make_pkt(1,data,checksum) yaitu membuat paket dan memberi sequence
                                                            number 1 dan menyertakan checksum yang akan dikirimkan lewat udt_send. </li>
                                                        <li>Lalu berada pada state ke 4 yaitu menunggu untuk ACK atau NAK dimana ada 2 kemungkinan yaitu jika NAK maka data rusak dan segera kembali mentransmisikan paket 1 melalui udt_send lagi. </li>
                                                        <li>Jika ACK maka paket 1 telah selesai. </li>
                                                    </p>

                                                    <p>&emsp; &emsp;&emsp;Receiver:
                                                        <img src="../../images/20.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">
                                                        <li>Pada state 1 disisi reveiver rdt_rcv menunggu panggilan 0 dari bawah(layer data link)
                                                        </li>
                                                        <li>Ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak, ada 3 kemungkinan yaitu Pertama, jika data rusak maka receiver menjalankan fungsi rdt_rcv(rcvpkt)&&(corrupt(rcvpkt)) dan
                                                            mengirimkan paket NAK dengan checksum melalui udt_send agar disisi sender menerima pemberitahuan paket rusak. kemudian menunggu packet data dengan sequence number 0 untuk dikirim. </li>
                                                        <li>Jika packet data utuh dan packet data diterima dengan sequence no.1, maka receiver mengirimkan packet ACK dan checksum melalui udt_send. dan kemudian menunggu packet data 0 untuk dikirim. </li>
                                                        <li>Jika packet data utuh dan packet data yang dikirim adalah packet data 0 maka menjalankan fungsi rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || has_seq0 dan mengirimkan paket ACK dengan checksum melalui
                                                            udt_send agar disisi sender menerima pemberitahuan paket sampai dan tidak rusak. </li>
                                                        <li>Jika paket utuh dan tidak eror maka selanjutnya akan dijalankan fungsi extract yaitu mengekstrak paket data dengan seq 0 untuk selanjutnya dikirim ke layer aplikasi(di sisi penerima). </li>
                                                        <li>State ke2 yaitu menunggu panggilan 1 dari bawah(layer data link) </li>
                                                        <li>Ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak, ada 3 kemungkinan yaitu jika data rusak maka menjalankan fungsi rdt_rcv(rcvpkt)&&(corrupt(rcvpkt)) dan mengirimkan paket
                                                            NAK dengan checksum melalui udt_send agar disisi sender menerima pemberitahuan paket rusak. </li>
                                                        <li>Kedua, Jika packet data utuh dan packet data diterima dengan sequence no.0, maka receiver memberikan ACK. kemudian receiver mengirimkan packet ACK dan checksum melalui udt_send. dan kemudian menunggu
                                                            packet data 1 untuk dikirim. </li>
                                                        <li>Ketiga,packet data utuh dan packet data yang dikirim adalah packet data 1 maka menjalankan fungsi rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || has_seq1 dan mengirimkan paket ACK dengan checksum melalui
                                                            udt_send agar disisi sender menerima pemberitahuan paket sampai dan tidak rusak. </li>
                                                    </p>

                                                    <h2>4. rdt2.2 </h2>
                                                    <p>&emsp; &emsp; Pada versi ini menangani jika ACK yang diterima adalah ACK untuk paket yang sama (duplicate ACK). Duplicate ACK terjadi karena pada versi ini NAK dihilangkan (mengabaikan NAK). Dengan demikian,
                                                        jika seandainya ACK yang diterima mengalami duplikasi, maka paket tersebut akan dikirim ulang. </p>

                                                    <p>&emsp;&emsp;&emsp;Sender:
                                                        <img src="../../images/21.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">

                                                        <li>State 1 menunggu panggilan dari atas (layer aplikasi) ketika ada perintah maka jalankan fungsi packet=make_pkt(0,data,checksum) yaitu membuat paket dan memberi sequence number 0 dan menyertakan checksum
                                                            yang akan dikirimkan lewat udt_send. </li>
                                                        <li>Lalu berada pada state ke 2 yaitu menunggu untuk ACK 0 dimana ada 2 kemungkinan yaitu jika menerima packet data rusak atau ACK 1 maka packet data kembali mentransmisikan paket 0 melalui udt_send
                                                            lagi. </li>
                                                        <li>Jika packet data tidak rusak dan menerima ACK 0 maka sudah benar dan telah selesai. </li>

                                                        <li>Pada state 3 yaitu menunggu panggilan dari atas (layer aplikasi) ketika ada perintah maka jalankan fungsi packet=make_pkt(1,data,checksum) yaitu membuat paket dan memberi sequence number 1 dan menyertakan
                                                            checksum yang akan dikirimkan lewat udt_send. </li>
                                                        <li>Lalu berada pada state ke 4 yaitu menunggu untuk ACK 1 dimana ada 2 kemungkinan yaitu jika menerima packet data rusak atau ACK 0 maka packet data kembali mentransmisikan paket 1 melalui udt_send
                                                            lagi. </li>
                                                        <li>Jika packet data tidak rusak dan menerima ACK 1 maka sudah benar dan telah selesai. </li>
                                                    </p>

                                                    <p>&emsp; &emsp;&emsp;Receiver:
                                                        <img src="../../images/22.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">
                                                        <li>State 1 disisi reveiver rdt_rcv menunggu panggilan packet data 0 dari bawah(layer data link), ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak, ada 2 kemungkinan yaitu jika
                                                            data corrupt atau packet data yang diterima adalah packet data sequence no.1,maka receiver akan mengirimkan ACK 1 dengan menjalankan fungsi udt_send(snd_pkt) kemudian menunggu kembali untuk packet
                                                            data 0 untuk dikirim. </li>
                                                        <li>Jika data utuh dan memiliki sequence no.0 maka menjalankan fungsi rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || has_seq0(rcvpkt) lalu menjalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya
                                                            dikirim ke layer aplikasi(di sisi penerima). Receiver juga mengirimkan paket ACK 0 dengan checksum melalui udt_send agar disisi sender menerima pemberitahuan paket sampai dan tidak rusak. </li>
                                                        <li>State 2 disisi reveiver rdt_rcv menunggu panggilan packet data 1 dari bawah(layer data link), ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak, ada 2 kemungkinan yaitu jika
                                                            data corrupt atau packet data yang diterima adalah packet data sequence no.0,maka receiver akan mengirimkan ACK 0 dengan menjalankan fungsi udt_send(snd_pkt) kemudian menunggu kembali untuk packet
                                                            data 1 untuk dikirim. </li>
                                                        <li>Jika data utuh dan memiliki sequence no.0, maka menjalankan fungsi rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || has_seq1(rcvpkt) lalu menjalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya
                                                            dikirim ke layer aplikasi(di sisi penerima). Receiver juga mengirimkan paket ACK 1 dengan checksum melalui udt_send agar disisi sender menerima pemberitahuan paket sampai dan tidak rusak. </li>
                                                    </p>

                                                    <h1>&emsp; Selanjutnya rdt versi 3.0 akan dijelaskan no 2 dan no 3 pada halaman web ini....
                                                    </h1>

                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>

                    <section id="content2">
                        <div class="menu-grids">
                            <div class="t-in">
                                <div class="text-info-sec">
                                    <div class="service-in text-left">
                                        <div class="cover">
                                            <div class="isian p-0 ">
                                                <h1 style="padding-left: 100px; padding-right: 50px; text-align: center;">Sender rdt 3.0</h1>
                                                <img src="../../images/23.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">


                                                <li>Pada state 1 menunggu panggilan dari atas (layer aplikasi) ketika ada perintah maka akan terjadi 2 kemungkinan. pertama, jalankan fungsi packet=make_pkt(0,data,checksum) yaitu membuat paket dan memberi sequence
                                                    number 0 dan menyertakan checksum yang akan dikirimkan lewat udt_send dan diberikan timer. </li>
                                                <li>Kedua, dari sisi sender akan menerima packet melalui fungsi rdt_rcv(rcvpkt). </li>
                                                <li>Pada state ke 2 yaitu menunggu untuk ACK 0 dimana ada 3 kemungkinan yaitu pertama jika packet data yang diterima rusak atau medapatkan ACK 1, maka langsung menunggu Kembali ACK 0 dari sisi penerima. </li>

                                                <li>Kedua, jika kehabisan waktu(timeout), maka packet data 0 akan dikirim ulang dan memulai ulang waktu Kembali. </li>
                                                <li>Ketiga, Jika packet data yang diterima tidak rusak dan mendapatkan ACK 0, maka hentikan waktunya. artinya packet data 0 sudah sampai di penerima. </li>
                                                <li>Pada state 3 yaitu menunggu panggilan dari atas (layer aplikasi) ketika ada perintah maka akan terjadi 2 kemungkinan. perama, jalankan fungsi packet=make_pkt(1,data,checksum) yaitu membuat paket dan memberi
                                                    sequence number 1 dan menyertakan checksum yang akan dikirimkan lewat udt_send dan diberikan timer. </li>


                                                <li>Pada state ke 4 yaitu menunggu untuk ACK 1 dimana ada 3 kemungkinan yaitu pertama jika packet data yang diterima rusak atau medapatkan ACK 0, maka langsung menunggu Kembali ACK 1 dari sisi penerima. </li>
                                                <li>Kedua, jika kehabisan waktu(timeout), maka packet data 1 akan dikirim ulang dan memulai ulang waktu Kembali. </li>
                                                <li>Ketiga, Jika packet data yang diterima tidak rusak dan mendapatkan ACK 1, maka hentikan waktunya. artinya packet data 1 sudah sampai di penerima.</li>
                                                </p>




                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>


                    <section id="content3">
                        <div class="menu-grids">
                            <div class="t-in">
                                <div class="text-info-sec">
                                    <div class="service-in text-left">
                                        <div class="cover">
                                            <div class="isian p-0 ">
                                                <h1 style="padding-left: 100px; padding-right: 50px; text-align: center;">Receiver rdt 3.0</h1>
                                                <img src="../../images/21.JPG " alt=" " style="display: block;margin-right: auto;margin-left: auto; width: 50%; height: auto; ">

                                                <p>&emsp; &emsp; FSM Receiver rdt3.0 sama dengan rdt2.2, dikarenakan rdt 2.2 FSM receiver bisa menghandle packet data yang hilang (loss). misalnya jika dari sisi pengirim mengirim packet data 0, yang datang
                                                    malah packet data 1. itu artinya packet data 0 tersebut hilang (loss). dengan implementasi FSM pada rdt2.2 itu, maka dari sisi receiver akan mengirimkan berupa ACK 1 untuk packet data 1,kemudian menunggu
                                                    Kembali hingga si pengirim mengirimkan packet data 0 lagi. Jika sudah mendapatkan packet data 0, maka dari sisi penerima akan mengirimkan balasan berupa ACK 0 kemudian packet data itu di dekapsulasi
                                                    kemudian di serahkan ke layer paling atas (application layer). Dengan state sebagai berikut :</p>

                                                <li>Pada state 1 disisi reveiver rdt_rcv menunggu panggilan packet data 0 dari bawah(layer data link), ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak, ada 2 kemungkinan yaitu jika
                                                    data corrupt atau packet data yang diterima adalah packet data sequence no.1,maka receiver akan mengirimkan ACK 1 dengan menjalankan fungsi udt_send(snd_pkt) kemudian menunggu kembali untuk packet data
                                                    0 untuk dikirim. </li>
                                                <li>Jika data utuh dan memiliki sequence no.0 maka menjalankan fungsi rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || has_seq0(rcvpkt) lalu menjalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya
                                                    dikirim ke layer aplikasi(di sisi penerima). Receiver juga mengirimkan paket ACK 0 dengan checksum melalui udt_send agar disisi sender menerima pemberitahuan paket sampai dan tidak rusak. </li>
                                                <li>Pada state 2 disisi reveiver rdt_rcv menunggu panggilan packet data 1 dari bawah(layer data link), ketika ada sinyal maka dia menerima paket dan mengeceknya rusak atau tidak, ada 2 kemungkinan yaitu jika
                                                    data corrupt atau packet data yang diterima adalah packet data sequence no.0,maka receiver akan mengirimkan ACK 0 dengan menjalankan fungsi udt_send(snd_pkt) kemudian menunggu kembali untuk packet data
                                                    1 untuk dikirim. </li>

                                                <li>Jika data utuh dan memiliki sequence no.0, maka menjalankan fungsi rdt_rcv(rcvpkt)&&(not corrupt(rcvpkt)) || has_seq1(rcvpkt) lalu menjalankan fungsi extract yaitu mengekstrak paket data untuk selanjutnya
                                                    dikirim ke layer aplikasi(di sisi penerima). Receiver juga mengirimkan paket ACK 1 dengan checksum melalui udt_send agar disisi sender menerima pemberitahuan paket sampai dan tidak rusak. </li>

                                                </p>




                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </section>




                </div>
            </div>
        </div>
    </section>


    <script>
        //text effect

        document.addEventListener('DOMContentLoaded', function(event) {

            var dataText = [
                "Fadhil Khusnul Hakim (D121191049) "
            ];

            // type one text in the typwriter
            // keeps calling itself until the text is finished
            function typeWriter(text, i, fnCallback) {
                // chekc if text isn't finished yet
                if (i < (text.length)) {
                    // add next character to h1
                    document.getElementById("text").innerHTML = text.substring(0, i + 1) +
                        '<span aria-hidden="true " class="banner_text_w3ls2 "></span>';

                    // wait for a while and call this function again for next character
                    setTimeout(function() {
                        typeWriter(text, i + 1, fnCallback)
                    }, 50);
                }
                // text finished, call callback if there is a callback function
                else if (typeof fnCallback == 'function') {
                    // call callback after timeout
                    setTimeout(fnCallback, 1000);
                }
            }
            // start a typewriter animation for a text in the dataText array
            function StartTextAnimation(i) {
                // check if dataText[i] exists

                if (i < dataText[i].length) {
                    // text exists! start typewriter animation
                    typeWriter(dataText[i], 0, function() {
                        // after callback (and whole text has been animated), start next text
                        StartTextAnimation(i + 1);
                    });
                }

            }

            // start the text animation




            StartTextAnimation(0);
        });
    </script>

    <script src="../../js/jquery-2.2.3.min.js "></script>
    <!-- //js -->
    <!-- few java snippets-->
    <script src="../../js/strive.js "></script>
    <!-- //few java snippets-->
    <!-- nav -->
    <script src="../../js/menuFullpage.min.js "></script>
    <!-- //nav -->
    <!-- smooth scroll -->
    <script src="../../js/SmoothScroll.min.js "></script>
    <!-- Bootstrap Core JavaScript -->
    <script src="../../js/bootstrap.js "></script>
    <!-- jQuery-Photo-filter-lightbox-Gallery-plugin -->
    <script src="../../js/jquery-1.7.2.js "></script>
    <script src="../../js/jquery.quicksand.js "></script>
    <script src="../../js/script.js "></script>
    <script src="../../js/jquery.prettyPhoto.js "></script>



    <!-- //jQuery-Photo-filter-lightbox-Gallery-plugin -->

</body>

</html>